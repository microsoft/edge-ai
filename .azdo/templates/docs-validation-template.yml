# Enhanced Documentation Validation Template
#
# Purpose:
# This template provides comprehensive documentation validation for Azure DevOps pull requests,
# ensuring documentation standards are maintained and the enhanced multi-section sidebar navigation
# stays synchronized with content changes across all documentation folders.
#
# Enhanced Functionality:
# - Validates enhanced multi-section sidebar navigation (docs/_parts/ structure)
# - Performs link validation across all documentation folders (docs, src, blueprints, praxisworx, .github, copilot)
# - Checks frontmatter consistency and required fields using Validate-MarkdownFrontmatter.ps1
# - Validates section-based navigation architecture with Generate-DocsSidebar.ps1
# - Ensures links don't contain language-specific paths (e.g., 'en-us') across entire repository
# - Provides detailed documentation health reporting with enhanced statistics
# - Supports the full enhanced documentation structure from Generate-DocsSidebar.ps1
#
# Parameters:
# - dependsOn: Jobs that this job depends on
# - displayName: Display name for this job
# - condition: Condition for running this job
# - breakBuild: Whether to treat validation failures as errors (true) or warnings (false)
# - onlyChangedFiles: Whether to validate only files changed in the PR/commit (true) or all files (false)
# - agentPool: Agent pool configuration
#
# Usage Examples:
# ```yaml
# # Basic usage for PR validation:
# - template: .azdo/templates/docs-validation-template.yml
#   parameters:
#     dependsOn: PreviousJob
#     displayName: "Enhanced Documentation Validation"
#
# # Changed files validation mode:
# - template: .azdo/templates/docs-validation-template.yml
#   parameters:
#     onlyChangedFiles: true
#     displayName: "Changed Files Documentation Validation"
# ```
#
# This template validates the complete enhanced documentation architecture including:
# - Multi-section navigation with docs/_parts/ structure
# - All documentation folders processed by Generate-DocsSidebar.ps1
# - Section-specific sidebars for improved navigation organization
# - Comprehensive content validation across the enhanced structure
---
parameters:
  # Dependencies for this job
  - name: dependsOn
    type: object
    default: []
  # Display name for the job
  - name: displayName
    type: string
    default: 'Documentation Validation'
  # Condition for when to run this job
  - name: condition
    type: string
    default: succeeded()
  # Whether to break the build on validation issues (true) or just show warnings (false)
  - name: breakBuild
    type: boolean
    default: false
  # Whether to validate only files changed in the PR/commit (true) or all files (false)
  - name: onlyChangedFiles
    type: boolean
    default: false
  # Agent pool configuration
  - name: agentPool
    type: object
    default:
      name: 'ai-on-edge-managed-pool'
      vmImage: 'ubuntu-latest'
  # Target branch for change comparison (default: main)
  - name: targetBranch
    type: string
    default: 'main'
  # Automatically detect PR target branch (overrides targetBranch when Build.Reason == PullRequest)
  - name: autoDetectTargetBranch
    type: boolean
    default: true

jobs:
  - job: DocsValidation
    displayName: ${{ parameters.displayName }}
    dependsOn: ${{ parameters.dependsOn }}
    condition: ${{ parameters.condition }}
    pool: ${{ parameters.agentPool }}

    steps:

      # Checkout repo
      - checkout: self
        clean: true

      # For PR builds, checkout the source branch HEAD instead of merge ref
      - task: Bash@3
        displayName: 'Checkout PR source branch HEAD'
        condition: eq(variables['Build.Reason'], 'PullRequest')
        inputs:
          targetType: 'inline'
          script: |
            BRANCH_NAME=$(echo "$(System.PullRequest.SourceBranch)" | sed 's|^refs/heads/||')
            echo "Switching to PR source branch HEAD: $BRANCH_NAME"
            git checkout "$BRANCH_NAME"
            git log -1 --oneline

      # Dynamically detect target branch for change comparison
      - bash: |
          if [ "$(Build.Reason)" == "PullRequest" ] && [ "${{ parameters.autoDetectTargetBranch }}" == "True" ]; then
            TARGET_BRANCH=$(echo "$(System.PullRequest.TargetBranch)" | sed 's|^refs/heads/||')
            echo "Auto-detected PR target branch: $TARGET_BRANCH"
          else
            TARGET_BRANCH="${{ parameters.targetBranch }}"
            echo "Using configured target branch: $TARGET_BRANCH"
          fi
          echo "##vso[task.setvariable variable=ComparisonTargetBranch]$TARGET_BRANCH"
        displayName: 'Detect comparison target branch'

      - task: PowerShell@2
        displayName: "Detect Markdown Changes"
        condition: and( not(failed()), not(canceled()) )
        inputs:
          targetType: 'inline'
          script: |
            Write-Host "Scanning for markdown changes..."
            git config --global --add safe.directory "$env:BUILD_SOURCESDIRECTORY"

            $docsChanged = $false
            $changedFiles = New-Object System.Collections.Generic.List[string]

            $targetBranch = $env:System_PullRequest_TargetBranch
            if ([string]::IsNullOrEmpty($targetBranch)) {
              $targetBranch = "refs/heads/$env:BUILD_SOURCEBRANCHNAME"
            }
            if ([string]::IsNullOrEmpty($targetBranch)) {
              $targetBranch = "refs/heads/main"
            }
            $targetBranch = $targetBranch -replace '^refs/heads/', ''

            try {
              git fetch origin $targetBranch --depth=200 | Out-Null
              $mergeBase = git merge-base HEAD ("origin/" + $targetBranch)
            } catch {
              $mergeBase = ""
            }

            if ([string]::IsNullOrEmpty($mergeBase)) {
              try {
                $mergeBase = git rev-parse HEAD~1
              } catch {
                $mergeBase = ""
              }
            }

            if ([string]::IsNullOrEmpty($mergeBase)) {
              $diff = git diff --name-only
            } else {
              $diff = git diff --name-only $mergeBase HEAD
            }

            if (-not [string]::IsNullOrEmpty($diff)) {
              foreach ($file in $diff.Split("`n", [System.StringSplitOptions]::RemoveEmptyEntries)) {
                $trimmed = $file.Trim()
                if ($trimmed.ToLower().EndsWith('.md')) {
                  $docsChanged = $true
                  $changedFiles.Add($trimmed)
                }
              }
            }

            if ($docsChanged) {
              Write-Host "Markdown changes detected:"
              $changedFiles | Sort-Object | ForEach-Object { Write-Host " - $_" }
              Write-Host "##vso[task.setvariable variable=DocsValidationShouldRun]true"
            } else {
              Write-Host "No markdown changes detected; skipping documentation validation steps."
              Write-Host "##vso[task.setvariable variable=DocsValidationShouldRun]false"
            }

      - task: PowerShell@2
        inputs:
          targetType: 'inline'
          script: |
            Write-Host "PowerShell version: $($PSVersionTable.PSVersion)"
        displayName: "Setup PowerShell Environment"
      - task: PowerShell@2
        inputs:
          targetType: 'inline'
          script: |
            Write-Host "üîç Starting frontmatter validation..."
            # Determine which files to validate
            $validateOnlyChanged = "${{ parameters.onlyChangedFiles }}" -eq "True"

            if ($validateOnlyChanged) {
              Write-Host "üìã Validating only changed files in this PR/commit"

              # Use the script's built-in git diff functionality
              try {
                $result = & "./scripts/Validate-MarkdownFrontmatter.ps1" -ChangedFilesOnly -Verbose
                $exitCode = $LASTEXITCODE
              }
              catch {
                Write-Host "‚ö†Ô∏è Could not determine changed files, falling back to full validation"
                $result = & "./scripts/Validate-MarkdownFrontmatter.ps1" -Verbose
                $exitCode = $LASTEXITCODE
              }
            } else {
              # Run full validation
              Write-Host "üìã Validating all markdown files"
              $result = & "./scripts/Validate-MarkdownFrontmatter.ps1" -Verbose
              $exitCode = $LASTEXITCODE
            }

            if ($exitCode -ne 0) {
              $message = "Frontmatter validation failed. Please check markdown file frontmatter."
              Write-Host "‚ùå $message" -ForegroundColor Red

              if ("${{ parameters.breakBuild }}" -eq "True") {
                Write-Host "##vso[task.logissue type=error]$message"
                exit 1
              } else {
                Write-Host "##vso[task.logissue type=warning]$message"
              }
            } else {
              Write-Host "‚úÖ Frontmatter validation completed successfully" -ForegroundColor Green
            }
        displayName: "Validate Frontmatter Consistency"
        condition: and( not(failed()), not(canceled()), eq(variables.DocsValidationShouldRun, 'true') )

      # Validate enhanced multi-section sidebar navigation
      - task: PowerShell@2
        inputs:
          targetType: 'inline'
          script: |
            Write-Host "üîç Validating enhanced multi-section navigation sidebar..."

            # Store original sidebar content for all sections
            $originalSidebars = @{}
            $sidebarPaths = @(
              "docs/_sidebar.md",
              "docs/_parts/docs-sidebar.md",
              "docs/_parts/praxisworx-sidebar.md",
              "docs/_parts/blueprints-sidebar.md",
              "docs/_parts/infrastructure-sidebar.md"
            )

            foreach ($path in $sidebarPaths) {
              if (Test-Path $path) {
                $originalSidebars[$path] = Get-Content $path -Raw
              }
            }

            # Run the enhanced sidebar generation
            . ./scripts/Generate-DocsSidebar.ps1

            # Validate each sidebar section
            $validationPassed = $true
            $issues = @()

            foreach ($path in $sidebarPaths) {
              if (Test-Path $path) {
                $newContent = Get-Content $path -Raw
                $originalContent = $originalSidebars[$path]

                # Compare content excluding timestamp differences
                $originalClean = ($originalContent -replace "<!-- Generated on:.*?-->", "")
                $newClean = ($newContent -replace "<!-- Generated on:.*?-->", "")

                if ($originalClean -ne $newClean) {
                  $issues += "- $path is outdated"
                  $validationPassed = $false

                  Write-Host "`nüìÑ Detailed diff for: $path" -ForegroundColor Yellow
                  Write-Host ("=" * 80) -ForegroundColor Yellow

                  # Show character counts to help identify differences
                  Write-Host "üìä Character counts:" -ForegroundColor Cyan
                  Write-Host "  Original (checked-in): $($originalClean.Length) chars" -ForegroundColor Cyan
                  Write-Host "  Generated (expected):  $($newClean.Length) chars" -ForegroundColor Cyan
                  Write-Host "  Difference: $($newClean.Length - $originalClean.Length) chars" -ForegroundColor Cyan

                  # Save to temp files for comparison
                  $tempOriginal = [System.IO.Path]::GetTempFileName()
                  $tempNew = [System.IO.Path]::GetTempFileName()
                  $originalClean | Set-Content $tempOriginal -NoNewline
                  $newClean | Set-Content $tempNew -NoNewline

                  if (Get-Command git -ErrorAction SilentlyContinue) {
                    Write-Host "`nüîç Git diff output:" -ForegroundColor Cyan
                    try {
                      $diffOutput = git diff --no-index --word-diff=plain --unified=3 $tempOriginal $tempNew 2>&1
                      if ($diffOutput) {
                        $diffOutput | ForEach-Object {
                          $line = $_
                          if ($line -match '^\+') {
                            Write-Host $line -ForegroundColor Green
                          } elseif ($line -match '^\-') {
                            Write-Host $line -ForegroundColor Red
                          } elseif ($line -match '^@@') {
                            Write-Host $line -ForegroundColor Cyan
                          } else {
                            Write-Host $line
                          }
                        }
                      }
                    } catch {
                      Write-Host "Git diff failed, falling back to PowerShell comparison" -ForegroundColor Yellow
                    }
                  }

                  Write-Host "`nüîç Line-by-line comparison (first 30 differences):" -ForegroundColor Cyan
                  $originalLines = $originalClean -split "`r?`n"
                  $newLines = $newClean -split "`r?`n"

                  Write-Host "Original has $($originalLines.Count) lines, Generated has $($newLines.Count) lines" -ForegroundColor Cyan

                  $comparison = Compare-Object -ReferenceObject $originalLines -DifferenceObject $newLines -IncludeEqual | Select-Object -First 30

                  $diffCount = 0
                  foreach ($diff in $comparison) {
                    if ($diff.SideIndicator -ne "==") {
                      $diffCount++
                      $indicator = if ($diff.SideIndicator -eq "<=") { "- ORIGINAL" } else { "+ GENERATED" }
                      $color = if ($diff.SideIndicator -eq "<=") { "Red" } else { "Green" }
                      Write-Host "$indicator`: $($diff.InputObject)" -ForegroundColor $color
                    }
                  }

                  if ($diffCount -eq 0) {
                    Write-Host "No line differences found, but content differs (possibly whitespace or encoding)" -ForegroundColor Yellow

                    Write-Host "`nüîç Checking for whitespace differences:" -ForegroundColor Cyan
                    $originalNoSpace = $originalClean -replace '\s+', ''
                    $newNoSpace = $newClean -replace '\s+', ''

                    if ($originalNoSpace -eq $newNoSpace) {
                      Write-Host "Content is identical when whitespace is removed - this is a whitespace-only difference" -ForegroundColor Yellow
                    } else {
                      Write-Host "Content differs even without whitespace" -ForegroundColor Yellow
                      Write-Host "Original (no space): $($originalNoSpace.Length) chars" -ForegroundColor Cyan
                      Write-Host "Generated (no space): $($newNoSpace.Length) chars" -ForegroundColor Cyan
                    }
                  }

                  Remove-Item $tempOriginal -ErrorAction SilentlyContinue
                  Remove-Item $tempNew -ErrorAction SilentlyContinue

                  Write-Host ("=" * 80) -ForegroundColor Yellow
                  Write-Host ""
                }
              }
            }

            if (-not (Test-Path "docs/_parts/")) {
              $issues += "- docs/_parts/ directory missing - required for multi-section navigation"
              $validationPassed = $false
            }

            if (-not $validationPassed) {
              $messageLines = @(
                "Sidebar validation failed:",
                ($issues -join "`n"),
                "",
                "Detailed comparison output is shown above."
              )
              $message = $messageLines -join "`n"

              Write-Host "‚ùå Sidebar validation failed!" -ForegroundColor Red
              Write-Host $message -ForegroundColor Red

              if ("${{ parameters.breakBuild }}" -eq "True") {
                Write-Host "##vso[task.logissue type=error]$message"
                exit 1
              } else {
                Write-Host "##vso[task.logissue type=warning]$message"
              }
            } else {
              Write-Host "‚úÖ All sidebar sections are up to date" -ForegroundColor Green
              exit 0
            }

            # If we reach here, validation failed - restore content before exit
            foreach ($path in $originalSidebars.Keys) {
              if ($originalSidebars[$path] -ne "") {
                $originalSidebars[$path] | Set-Content $path -NoNewline
              }
            }
        displayName: "Validate Enhanced Multi-Section Sidebar Navigation"
        condition: and( not(failed()), not(canceled()), eq(variables.DocsValidationShouldRun, 'true') )

      # Set up Node.js for link validation
      - task: NodeTool@0
        inputs:
          versionSpec: '18'
        displayName: "Setup Node.js"
        condition: and( not(failed()), not(canceled()), eq(variables.DocsValidationShouldRun, 'true') )

      # Install markdown-link-check
      - bash: |
          npm install -g markdown-link-check
        displayName: "Install markdown-link-check"
        condition: and( not(failed()), not(canceled()), eq(variables.DocsValidationShouldRun, 'true') )

      # Validate documentation links
      - bash: |
          echo "üîó Checking links in documentation files..."

          # Create config file for link checking
          cat > .markdown-link-check.json << EOF
          {
            "ignorePatterns": [
              {
                "pattern": "^http://localhost"
              },
              {
                "pattern": "^https://localhost"
              },
              {
                "pattern": "^#"
              }
            ],
            "timeout": "10s",
            "retryOn429": true,
            "retryCount": 3,
            "fallbackOnError": true
          }
          EOF

          # Determine which files to check
          validate_only_changed="${{ parameters.onlyChangedFiles }}"
          link_errors=0

          if [ "$validate_only_changed" = "True" ]; then
            echo "üìã Validating links only in changed files"

            # Get changed markdown files
            changed_files=""
            comparison_target="origin/$(ComparisonTargetBranch)"
            if git merge-base HEAD "$comparison_target" >/dev/null 2>&1; then
              changed_files=$(git diff --name-only $(git merge-base HEAD "$comparison_target") HEAD | grep '\.md$' || true)
            else
              # Fallback to HEAD~1 if merge-base fails
              changed_files=$(git diff --name-only HEAD~1 HEAD | grep '\.md$' || true)
            fi

            if [ -z "$changed_files" ]; then
              echo "No changed markdown files found - skipping link validation"
              exit 0
            fi

            echo "Found changed markdown files:"
            echo "$changed_files"

            # Check each changed file
            for file in $changed_files; do
              if [ -f "$file" ]; then
                echo "Checking: $file"
                if ! markdown-link-check "$file" --config .markdown-link-check.json; then
                  if [ "${{ parameters.breakBuild }}" = "True" ]; then
                    echo "##vso[task.logissue type=error]Link validation failed in: $file"
                  else
                    echo "##vso[task.logissue type=warning]Link validation failed in: $file"
                  fi
                  link_errors=$((link_errors + 1))
                fi
              fi
            done
          else
            echo "üìã Validating links in all documentation files"

            # Check all markdown files in tracked folders (includes enhanced documentation structure)
            find docs src blueprints praxisworx .github copilot -name "*.md" -type f 2>/dev/null | \
              grep -v node_modules | \
              while read file; do
                echo "Checking: $file"
                if ! markdown-link-check "$file" --config .markdown-link-check.json; then
                  if [ "${{ parameters.breakBuild }}" = "True" ]; then
                    echo "##vso[task.logissue type=error]Link validation failed in: $file"
                  else
                    echo "##vso[task.logissue type=warning]Link validation failed in: $file"
                  fi
                  link_errors=$((link_errors + 1))
                fi
              done
          fi

          if [ $link_errors -gt 0 ] && [ "${{ parameters.breakBuild }}" = "True" ]; then
            echo "‚ùå Link validation failed with $link_errors errors"
            exit 1
          else
            echo "‚úÖ Link validation completed"
          fi
        displayName: "Validate Documentation Links"
        condition: and( not(failed()), not(canceled()), eq(variables.DocsValidationShouldRun, 'true') )

      # Generate documentation health report
      - task: PowerShell@2
        inputs:
          targetType: 'inline'
          script: |
            Write-Host "üìä Generating documentation health report..."

            # Count documentation files by type (enhanced structure)
            $docsCount = (Get-ChildItem -Path 'docs' -Filter '*.md' -Recurse -ErrorAction SilentlyContinue).Count
            $srcCount = (Get-ChildItem -Path 'src' -Filter '*.md' -Recurse -ErrorAction SilentlyContinue).Count
            $blueprintsCount = (Get-ChildItem -Path 'blueprints' -Filter '*.md' -Recurse -ErrorAction SilentlyContinue).Count
            $praxisworxCount = (Get-ChildItem -Path 'praxisworx' -Filter '*.md' -Recurse -ErrorAction SilentlyContinue).Count
            $githubCount = (Get-ChildItem -Path '.github' -Filter '*.md' -Recurse -ErrorAction SilentlyContinue).Count
            $copilotCount = (Get-ChildItem -Path 'copilot' -Filter '*.md' -Recurse -ErrorAction SilentlyContinue).Count

            # Check section-based navigation structure
            $sectionStructure = @()
            $sectionPaths = @(
              "docs/_parts/docs-sidebar.md",
              "docs/_parts/praxisworx-sidebar.md",
              "docs/_parts/blueprints-sidebar.md",
              "docs/_parts/infrastructure-sidebar.md"
            )

            foreach ($path in $sectionPaths) {
              $status = if (Test-Path $path) { "‚úÖ" } else { "‚ùå" }
              $sectionName = (Split-Path $path -Leaf) -replace "-sidebar.md", ""
              $sectionStructure += "- $status $sectionName section: $path"
            }

            # Generate enhanced health report
            $report = @"
            # üìö Enhanced Documentation Health Report

            Generated on: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss UTC')

            ## üìà Documentation Statistics

            | Category | File Count |
            |----------|------------|
            | Main Documentation | $docsCount |
            | Infrastructure Components | $srcCount |
            | Blueprints | $blueprintsCount |
            | Learning Platform (PraxisWorx) | $praxisworxCount |
            | GitHub Resources | $githubCount |
            | AI Assistant Guides (Copilot) | $copilotCount |
            | **Total** | **$($docsCount + $srcCount + $blueprintsCount + $praxisworxCount + $githubCount + $copilotCount)** |

            ## üèóÔ∏è Multi-Section Navigation Architecture

            ### Section-Based Sidebars
            $($sectionStructure -join "`n")

            ### Enhanced Three-Tree Architecture Status
            - ‚úÖ Bicep Documentation Tree: Auto-generated navigation
            - ‚úÖ Terraform Documentation Tree: Auto-generated navigation
            - ‚úÖ README Documentation Tree: Manual README organization
            - ‚úÖ Multi-Section Navigation: Section-specific sidebars in docs/_parts/

            ## üîç Validation Results

            - Frontmatter Validation: Completed
            - Enhanced Multi-Section Sidebar Validation: Completed
            - Link Validation: Completed (includes copilot/ folder)
            - Documentation Standards: Verified

            ---

            *This report is automatically generated during enhanced documentation validation.*
            "@

            Write-Host $report

            # Save report as artifact
            $report | Out-File -FilePath 'documentation-health-report.md' -Encoding UTF8

            Write-Host "‚úÖ Documentation health report generated"
        displayName: "Generate Documentation Health Report"
        condition: and( always(), eq(variables.DocsValidationShouldRun, 'true') )

      # Check for en-us links in docs
      - task: PowerShell@2
        displayName: "Check for language path segments in links"
        inputs:
          targetType: 'inline'
          script: |
            Write-Host "Checking for language path segments (en-us) in links..."

            # Run the PowerShell script and capture JSON output
            $jsonOutput = & "$(System.DefaultWorkingDirectory)/scripts/linting/Link-Lang-Check.ps1"
            $links = $jsonOutput | ConvertFrom-Json

            if ($links.Count -gt 0) {
              Write-Host "Found $($links.Count) URLs with language path segments (en-us)."

              $breakBuild = "${{ parameters.breakBuild }}" -eq "true" -or "${{ parameters.breakBuild }}" -eq "True"

              foreach ($link in $links) {
                $issueType = if ($breakBuild) { "error" } else { "warning" }
                $message = "URL contains language path segment (en-us): $($link.original_url)"
                Write-Host "##vso[task.logissue type=$issueType;sourcepath=$($link.file);linenumber=$($link.line_number);]$message"
              }

              if ($breakBuild) {
                Write-Host "##vso[task.complete result=Failed;]Build failed due to language path segments in URLs"
                exit 1
              }
            } else {
              Write-Host "No URLs with language path segments (en-us) found."
            }
          workingDirectory: '$(System.DefaultWorkingDirectory)'
        condition: and( not(failed()), not(canceled()), eq(variables.DocsValidationShouldRun, 'true') )

      # Upload documentation health report as artifact
      - task: PublishPipelineArtifact@1
        condition: and( always(), eq(variables.DocsValidationShouldRun, 'true') )
        displayName: Upload Documentation Health Report
        inputs:
          targetPath: "documentation-health-report.md"
          artifactName: DocumentationHealthReport
