# MegaLinter Template
#
# Purpose:
# This template integrates MegaLinter into the pipeline to perform comprehensive code quality
# checks across multiple languages and file types, ensuring consistent code standards throughout
# the repository.
#
# Functionality:
# - Pulls MegaLinter from Docker registry
# - Executes MegaLinter against the codebase with customizable configurations
# - Optionally posts comments on pull requests with linting results
# - Publishes linting reports as pipeline artifacts
#
# Parameters:
# - dependsOn: Jobs that this job depends on
# - displayName: Display name for this job
# - condition: Condition for running this job
# - enableAzureReporter: When true, posts results as comments on Azure DevOps PRs
# - pullRequestId: ID of the pull request (required for PR comments)
# - sourceRepoUri: URI of the source repository (required for PR comments)
# - agentPool: Agent pool configuration with name and vmImage properties
#
# Usage Examples:
# ```yaml
# # Basic usage:
# - template: .azdo/templates/megalinter-template.yml
#   parameters:
#     dependsOn: PreviousJob
#
# # With PR commenting enabled:
# - template: .azdo/templates/megalinter-template.yml
#   parameters:
#     enableAzureReporter: true
#     pullRequestId: $(System.PullRequest.PullRequestId)
#     sourceRepoUri: $(System.PullRequest.SourceRepositoryURI)
# ```
#
# MegaLinter provides a unified approach to code quality by running multiple linters
# in parallel, significantly improving code quality and consistency across the project.
---
parameters:
  # Dependencies for this job
  - name: dependsOn
    type: object
    default: []
  # Display name for the job
  - name: displayName
    type: string
    default: 'Run MegaLinter'
  # Condition for when to run this job
  - name: condition
    type: string
    default: succeeded()
  # Enable or disable Azure Reporter
  - name: enableAzureReporter
    type: boolean
    default: false
  # ID of the pull request
  - name: pullRequestId
    type: string
    default: ''
  # URI of the source repository
  - name: sourceRepoUri
    type: string
    default: ''
  # Agent pool configuration
  - name: agentPool
    type: object
    default:
      name: 'ai-on-edge-managed-pool'
      vmImage: 'ubuntu-latest'

jobs:
  - job: MegaLinter
    dependsOn: ${{ parameters.dependsOn }}
    displayName: ${{ parameters.displayName }}
    condition: ${{ parameters.condition }}
    pool: ${{ parameters.agentPool }}
    variables:
      MegaLinterGitleaksArgs: ''

    steps:
      # Checkout repo
      - checkout: self
        clean: true
        fetchDepth: 0
        fetchTags: false
        persistCredentials: true

      - pwsh: |
          $ErrorActionPreference = 'Stop'
          Set-StrictMode -Version 3.0

          function Invoke-Git {
            param(
              [Parameter(Mandatory)]
              [string[]]$Args,
              [switch]$AllowFailure
            )

            & git @Args
            $exitCode = $LASTEXITCODE
            if ($exitCode -ne 0) {
              if ($AllowFailure) {
                Write-Host "git $($Args -join ' ') exited with $exitCode; continuing."
              } else {
                throw "git $($Args -join ' ') exited with $exitCode"
              }
            }
            return $exitCode
          }

          Write-Host "Remote branches before cleanup:"
          Invoke-Git -Args @('for-each-ref', '--format=  %(refname:strip=2)', 'refs/remotes/origin')

          $sourceBranch = $env:SYSTEM_PULLREQUEST_SOURCEBRANCH
          $targetBranch = $env:SYSTEM_PULLREQUEST_TARGETBRANCH

          if ($null -ne $sourceBranch) {
            $sourceBranch = $sourceBranch -replace '^refs/heads/', ''
          } else {
            $sourceBranch = ''
          }

          if ($null -ne $targetBranch) {
            $targetBranch = $targetBranch -replace '^refs/heads/', ''
          } else {
            $targetBranch = ''
          }

          if ([string]::IsNullOrWhiteSpace($sourceBranch)) {
            Write-Host "No PR source branch detected; skipping branch cleanup."
            exit 0
          }

          if ([string]::IsNullOrWhiteSpace($targetBranch)) {
            $targetBranch = $env:BUILD_SOURCEBRANCHNAME
          }

          if ([string]::IsNullOrWhiteSpace($targetBranch)) {
            $targetBranch = 'main'
          }

          $remoteName = 'origin'

          $refspecs = @()

          if (-not [string]::IsNullOrWhiteSpace($sourceBranch)) {
            $sourceExit = Invoke-Git -Args @('ls-remote', '--exit-code', '--heads', $remoteName, $sourceBranch) -AllowFailure
            if ($sourceExit -eq 0) {
              $refspecs += "+refs/heads/$sourceBranch:refs/remotes/$remoteName/$sourceBranch"
            } else {
              Write-Host "Source branch '$sourceBranch' not found on $remoteName; skipping remote fetch for it."
            }
          }

          $targetCandidates = @()

          if (-not [string]::IsNullOrWhiteSpace($targetBranch)) {
            $targetCandidates += $targetBranch
          }

          $remoteHeadBranch = ''
          try {
            $headOutput = (& git symbolic-ref "refs/remotes/$remoteName/HEAD" 2>$null)
            if ($LASTEXITCODE -eq 0 -and $null -ne $headOutput) {
              $headRef = $headOutput | Select-Object -First 1
              if ($null -ne $headRef) {
                $headRef = $headRef.Trim()
                if ($headRef -match "^refs/remotes/$remoteName/(.+)$") {
                  $remoteHeadBranch = $Matches[1]
                }
              }
            }
          } catch {
            $remoteHeadBranch = ''
          }

          if (-not [string]::IsNullOrWhiteSpace($remoteHeadBranch) -and $targetCandidates -notcontains $remoteHeadBranch) {
            $targetCandidates += $remoteHeadBranch
          }

          if ($targetCandidates -notcontains 'main') {
            $targetCandidates += 'main'
          }

          $masterExists = Invoke-Git -Args @('show-ref', '--verify', '--quiet', "refs/remotes/$remoteName/master") -AllowFailure
          if ($masterExists -eq 0 -and $targetCandidates -notcontains 'master') {
            $targetCandidates += 'master'
          }

          $targetAdded = $false

          foreach ($candidate in $targetCandidates) {
            if ([string]::IsNullOrWhiteSpace($candidate)) {
              continue
            }

            if ($candidate -eq $sourceBranch) {
              $targetAdded = $true
              $targetBranch = $candidate
              break
            }

            $targetExit = Invoke-Git -Args @('ls-remote', '--exit-code', '--heads', $remoteName, $candidate) -AllowFailure

            if ($targetExit -eq 0) {
              $refspecs += "+refs/heads/$candidate:refs/remotes/$remoteName/$candidate"
              $targetBranch = $candidate
              $targetAdded = $true
              break
            }
          }

          if (-not $targetAdded) {
            Write-Host "Target branch '$targetBranch' not found on $remoteName; relying on fallbacks."
          }

          Invoke-Git -Args @('config', '--unset-all', 'remote.origin.fetch') -AllowFailure

          if ($refspecs.Count -eq 0) {
            Write-Host 'No matching remote branches detected; restoring default fetch configuration.'
            Invoke-Git -Args @('config', '--add', 'remote.origin.fetch', "+refs/heads/*:refs/remotes/$remoteName/*")
            Invoke-Git -Args @('fetch', $remoteName, '--prune', '--prune-tags', '--no-recurse-submodules') -AllowFailure
            Invoke-Git -Args @('remote', 'set-head', $remoteName, '--auto') -AllowFailure
            Write-Host "Remote branches after cleanup:"
            Invoke-Git -Args @('for-each-ref', '--format=  %(refname:strip=2)', "refs/remotes/$remoteName")
            exit 0
          }

          foreach ($refspec in $refspecs) {
            Invoke-Git -Args @('config', '--add', 'remote.origin.fetch', $refspec)
          }

          Write-Host "Configuring remote.origin.fetch for source=$sourceBranch target=$targetBranch"

          Invoke-Git -Args @('fetch', $remoteName, '--prune', '--prune-tags', '--no-recurse-submodules')

          Invoke-Git -Args @('remote', 'set-head', $remoteName, '--auto') -AllowFailure

          Write-Host "Remote branches after cleanup:"
          Invoke-Git -Args @('for-each-ref', '--format=  %(refname:strip=2)', "refs/remotes/$remoteName")
        displayName: 'Limit remote branches for MegaLinter diff mode'
        condition: and(succeeded(), eq(variables['Build.Reason'], 'PullRequest'))

      - pwsh: |
          $ErrorActionPreference = 'Stop'

          if ('$(Build.Reason)' -eq 'PullRequest') {
            $value = '--log-opts="origin/$(System.PullRequest.TargetBranch)..HEAD"'
          } else {
            $value = ''
          }

          Write-Host "Setting MegaLinterGitleaksArgs to '$value'"
          Write-Host "##vso[task.setvariable variable=MegaLinterGitleaksArgs]$value"
        displayName: 'Configure MegaLinter Git diff arguments'

      - script: |

          # Pull MegaLinter from GitHub registry
          echo "Pulling MegaLinter from GitHub registry..."
          docker pull ghcr.io/oxsecurity/megalinter:v8

        displayName: MegaLinter Pull
        condition: not(canceled())

      # Run MegaLinter with different configurations based on Azure Reporter setting
      - ${{ if eq(parameters.enableAzureReporter, true) }}:
          - script: |
              GITLEAKS_ENV=""
              if [ -n "$(MegaLinterGitleaksArgs)" ]; then
                GITLEAKS_ENV="-e REPOSITORY_GITLEAKS_ARGUMENTS=\"$(MegaLinterGitleaksArgs)\""
              fi

              eval docker run -v $(System.DefaultWorkingDirectory):/tmp/lint \
                --env-file '<(env | grep -e SYSTEM_ -e BUILD_ -e TF_ -e AGENT_)' \
                -e SYSTEM_ACCESSTOKEN=$(System.AccessToken) \
                -e GIT_AUTHORIZATION_BEARER=$(System.AccessToken) \
                ${GITLEAKS_ENV} \
                -e SYSTEM_COLLECTIONURI='$(System.CollectionUri)' \
                -e SYSTEM_PULLREQUEST_PULLREQUESTID='${{ parameters.pullRequestId }}' \
                -e SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI='${{ parameters.sourceRepoUri }}' \
                -e SYSTEM_TEAMPROJECT='$(System.TeamProject)' \
                -e BUILD_BUILDID='$(Build.BuildId)' \
                -e BUILD_REPOSITORY_ID='$(Build.Repository.ID)' \
                -e AZURE_COMMENT_REPORTER='true' \
                oxsecurity/megalinter:v8

            displayName: Run MegaLinter

      - ${{ if eq(parameters.enableAzureReporter, false) }}:
          - script: |
              GITLEAKS_ENV=""
              if [ -n "$(MegaLinterGitleaksArgs)" ]; then
                GITLEAKS_ENV="-e REPOSITORY_GITLEAKS_ARGUMENTS=\"$(MegaLinterGitleaksArgs)\""
              fi

              eval docker run -v $(System.DefaultWorkingDirectory):/tmp/lint \
                --env-file '<(env | grep -e SYSTEM_ -e BUILD_ -e TF_ -e AGENT_)' \
                -e SYSTEM_ACCESSTOKEN=$(System.AccessToken) \
                -e GIT_AUTHORIZATION_BEARER=$(System.AccessToken) \
                ${GITLEAKS_ENV} \
                -e AZURE_COMMENT_REPORTER='false' \
                oxsecurity/megalinter:v8

            displayName: Run MegaLinter

      # Upload MegaLinter reports as artifacts
      - task: PublishPipelineArtifact@1
        condition: succeededOrFailed()
        displayName: Upload MegaLinter reports
        inputs:
          targetPath: "$(System.DefaultWorkingDirectory)/megalinter-reports/"
          artifactName: MegaLinterReport

      # Emit actual error details from ERROR-*.log files as individual Azure DevOps errors
      - script: |
          set -euo pipefail
          LOG_DIR="$(System.DefaultWorkingDirectory)/megalinter-reports/linters_logs"
          if [ ! -d "$LOG_DIR" ]; then
            echo "No linters_logs directory found at $LOG_DIR"
            exit 0
          fi

          shopt -s nullglob
          error_files=("$LOG_DIR"/ERROR-*.log)

          for f in "${error_files[@]}"; do
            rel_path="${f#$(System.DefaultWorkingDirectory)/}"
            after_marker=0
            capture_error_details=0

            while IFS= read -r line || [ -n "$line" ]; do
              # Look for the ERROR marker to start processing
              if [ $after_marker -eq 0 ]; then
                if [[ "$line" == "âŒ [ERROR]"* ]]; then
                  after_marker=1
                fi
                continue
              fi

              # Skip empty lines
              [ -z "$line" ] && continue

              # Check if this line indicates an error (ends with " X")
              if [[ "$line" == *" X" ]]; then
                capture_error_details=1
                continue
              fi

              # Check if we've hit the next numbered progress line (stop capturing)
              if [[ "$line" =~ ^[[:space:]]*[0-9]+/[0-9]+ ]]; then
                capture_error_details=0
                continue
              fi

              # Check if we've hit the summary line at the end (stop capturing)
              if [[ "$line" =~ ^.*:\ Files\ checked ]]; then
                capture_error_details=0
                continue
              fi

              # If we're capturing error details, emit them as Azure DevOps errors
              if [ $capture_error_details -eq 1 ]; then
                esc="${line//'%'/'%25'}"
                esc="${esc//']'/'%5D'}"
                esc="${esc//';'/'%3B'}"
                echo "##vso[task.logissue type=error;sourcepath=$rel_path;]$esc"
              fi
            done < "$f"
          done
        displayName: Emit MegaLinter error details
        condition: succeededOrFailed()
