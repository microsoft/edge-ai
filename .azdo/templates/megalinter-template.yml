# MegaLinter Template
#
# Purpose:
# This template integrates MegaLinter into the pipeline to perform comprehensive code quality
# checks across multiple languages and file types, ensuring consistent code standards throughout
# the repository.
#
# Functionality:
# - Pulls MegaLinter from Docker registry
# - Executes MegaLinter against the codebase with customizable configurations
# - Optionally posts comments on pull requests with linting results
# - Publishes linting reports as pipeline artifacts
#
# Parameters:
# - dependsOn: Jobs that this job depends on
# - displayName: Display name for this job
# - condition: Condition for running this job
# - enableAzureReporter: When true, posts results as comments on Azure DevOps PRs
# - pullRequestId: ID of the pull request (required for PR comments)
# - sourceRepoUri: URI of the source repository (required for PR comments)
# - agentPool: Agent pool configuration with name and vmImage properties
#
# Usage Examples:
# ```yaml
# # Basic usage:
# - template: .azdo/templates/megalinter-template.yml
#   parameters:
#     dependsOn: PreviousJob
#
# # With PR commenting enabled:
# - template: .azdo/templates/megalinter-template.yml
#   parameters:
#     enableAzureReporter: true
#     pullRequestId: $(System.PullRequest.PullRequestId)
#     sourceRepoUri: $(System.PullRequest.SourceRepositoryURI)
# ```
#
# MegaLinter provides a unified approach to code quality by running multiple linters
# in parallel, significantly improving code quality and consistency across the project.
---
parameters:
  # Dependencies for this job
  - name: dependsOn
    type: object
    default: []
  # Display name for the job
  - name: displayName
    type: string
    default: 'Run MegaLinter'
  # Condition for when to run this job
  - name: condition
    type: string
    default: succeeded()
  # Enable or disable Azure Reporter
  - name: enableAzureReporter
    type: boolean
    default: false
  # ID of the pull request
  - name: pullRequestId
    type: string
    default: ''
  # URI of the source repository
  - name: sourceRepoUri
    type: string
    default: ''
  # Agent pool configuration
  - name: agentPool
    type: object
    default:
      name: 'ai-on-edge-managed-pool'
      vmImage: 'ubuntu-latest'

jobs:
  - job: MegaLinter
    dependsOn: ${{ parameters.dependsOn }}
    displayName: ${{ parameters.displayName }}
    condition: ${{ parameters.condition }}
    pool: ${{ parameters.agentPool }}

    steps:
      # Checkout repo
      - checkout: self
        clean: true

      - script: |

          # Pull MegaLinter from GitHub registry
          echo "Pulling MegaLinter from GitHub registry..."
          docker pull ghcr.io/oxsecurity/megalinter:v8

        displayName: MegaLinter Pull
        condition: not(canceled())

      # Run MegaLinter with different configurations based on Azure Reporter setting
      - ${{ if eq(parameters.enableAzureReporter, true) }}:
          - script: |

              docker run -v $(System.DefaultWorkingDirectory):/tmp/lint \
                --env-file <(env | grep -e SYSTEM_ -e BUILD_ -e TF_ -e AGENT_) \
                -e SYSTEM_ACCESSTOKEN=$(System.AccessToken) \
                -e GIT_AUTHORIZATION_BEARER=$(System.AccessToken) \
                -e SYSTEM_COLLECTIONURI='$(System.CollectionUri)' \
                -e SYSTEM_PULLREQUEST_PULLREQUESTID='${{ parameters.pullRequestId }}' \
                -e SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI='${{ parameters.sourceRepoUri }}' \
                -e SYSTEM_TEAMPROJECT='$(System.TeamProject)' \
                -e BUILD_BUILDID='$(Build.BuildId)' \
                -e BUILD_REPOSITORY_ID='$(Build.Repository.ID)' \
                -e AZURE_COMMENT_REPORTER='true' \
                oxsecurity/megalinter:v8

            displayName: Run MegaLinter

      - ${{ if eq(parameters.enableAzureReporter, false) }}:
          - script: |

              docker run -v $(System.DefaultWorkingDirectory):/tmp/lint \
                --env-file <(env | grep -e SYSTEM_ -e BUILD_ -e TF_ -e AGENT_) \
                -e SYSTEM_ACCESSTOKEN=$(System.AccessToken) \
                -e GIT_AUTHORIZATION_BEARER=$(System.AccessToken) \
                -e AZURE_COMMENT_REPORTER='false' \
                oxsecurity/megalinter:v8

            displayName: Run MegaLinter

      # Upload MegaLinter reports as artifacts
      - task: PublishPipelineArtifact@1
        condition: succeededOrFailed()
        displayName: Upload MegaLinter reports
        inputs:
          targetPath: "$(System.DefaultWorkingDirectory)/megalinter-reports/"
          artifactName: MegaLinterReport

      # Emit actual error details from ERROR-*.log files as individual Azure DevOps errors
      - script: |
          set -euo pipefail
          LOG_DIR="$(System.DefaultWorkingDirectory)/megalinter-reports/linters_logs"
          if [ ! -d "$LOG_DIR" ]; then
            echo "No linters_logs directory found at $LOG_DIR"
            exit 0
          fi

          shopt -s nullglob
          error_files=("$LOG_DIR"/ERROR-*.log)

          for f in "${error_files[@]}"; do
            rel_path="${f#$(System.DefaultWorkingDirectory)/}"
            after_marker=0
            capture_error_details=0

            while IFS= read -r line || [ -n "$line" ]; do
              # Look for the ERROR marker to start processing
              if [ $after_marker -eq 0 ]; then
                if [[ "$line" == "âŒ [ERROR]"* ]]; then
                  after_marker=1
                fi
                continue
              fi

              # Skip empty lines
              [ -z "$line" ] && continue

              # Check if this line indicates an error (ends with " X")
              if [[ "$line" == *" X" ]]; then
                capture_error_details=1
                continue
              fi

              # Check if we've hit the next numbered progress line (stop capturing)
              if [[ "$line" =~ ^[[:space:]]*[0-9]+/[0-9]+ ]]; then
                capture_error_details=0
                continue
              fi

              # Check if we've hit the summary line at the end (stop capturing)
              if [[ "$line" =~ ^.*:\ Files\ checked ]]; then
                capture_error_details=0
                continue
              fi

              # If we're capturing error details, emit them as Azure DevOps errors
              if [ $capture_error_details -eq 1 ]; then
                esc="${line//'%'/'%25'}"
                esc="${esc//']'/'%5D'}"
                esc="${esc//';'/'%3B'}"
                echo "##vso[task.logissue type=error;sourcepath=$rel_path;]$esc"
              fi
            done < "$f"
          done
        displayName: Emit MegaLinter error details
        condition: succeededOrFailed()
