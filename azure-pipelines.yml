# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

---
trigger:
  branches:
    include:
      - main

variables:
  isMain: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]

pool:
  name: ai-on-edge-managed-pool
  vmImage: ubuntu-latest

stages:
  - stage: Main
    displayName: Main Build
    # dependsOn: string | [ string ]
    condition: eq(variables.isMain, true)
    # pool: string | pool
    # variables: { string: string } | [ variable | variableReference ]
    jobs:
      - job: DependencyScan
        pool:
          name: ai-on-edge-managed-pool
          vmImage: ubuntu-latest
        steps:
          # Set the agent name as an output variable so the same agent runs all jobs
          - bash: |
              echo "##vso[task.setvariable variable=AgentName;isoutput=true]$(Agent.Name)"
            name: passOutputVar

          # Checkout repo
          - checkout: self

          # Initialize dependency scan and fail the build if it does not pass
          - task: ms.vss-governance-buildtask.governance-build-task-component-detection.ComponentGovernanceComponentDetection@0
            displayName: "Component Detection"
            inputs:
              failOnAlert: true

      # Run MegaLinter to detect linting and security issues
      - job: MegaLinter
        dependsOn: DependencyScan
        variables:
          AgentName: $[ dependencies.A.outputs['passOutput.AgentName'] ]
        pool:
          name: ai-on-edge-managed-pool
          vmImage: ubuntu-latest
          demands: Agent.Name -equals $(Agent.Name)

        steps:
          # Checkout repo
          - checkout: self

          # Pull MegaLinter docker image
          - script: docker pull oxsecurity/megalinter:v7
            displayName: Pull MegaLinter

          # Run MegaLinter - for the main branch the reporter needs to be disabled
          - script: |
              docker run -v $(System.DefaultWorkingDirectory):/tmp/lint \
                --env-file <(env | grep -e SYSTEM_ -e BUILD_ -e TF_ -e AGENT_) \
                -e SYSTEM_ACCESSTOKEN=$(System.AccessToken) \
                -e GIT_AUTHORIZATION_BEARER=$(System.AccessToken) \
                -e AZURE_COMMENT_REPORTER='false' \
                oxsecurity/megalinter:v7
            displayName: Run MegaLinter

  - stage: PR
    displayName: PR Build Process
    # dependsOn: string | [ string ]
    condition: eq(variables.isMain, false)
    # pool: string | pool
    # variables: { string: string } | [ variable | variableReference ]
    jobs:
      - job: AgentAssign
        steps:
          # Set the agent name as an output variable so the same agent runs all jobs
          - bash: |
              echo "##vso[task.setvariable variable=AgentName;isoutput=true]$(Agent.Name)"
            name: passAgentNameOutput

      - job: DependencyScan
        dependsOn: AgentAssign
        variables:
          AgentName: $[ dependencies.AgentAssign.outputs['agentNameScript.AgentName'] ]
        pool:
          name: ai-on-edge-managed-pool
          vmImage: ubuntu-latest
          demands: Agent.Name -equals $(Agent.Name)
        steps:
          # Checkout repo
          - checkout: self

          # Initialize dependency scan and fail the build if it does not pass
          - task: ms.vss-governance-buildtask.governance-build-task-component-detection.ComponentGovernanceComponentDetection@0
            displayName: "Component Detection"
            inputs:
              failOnAlert: true

      # Run MegaLinter to detect linting and security issues
      - job: MegaLinter
        dependsOn:
          - AgentAssign
          - DependencyScan
        variables:
          AgentName: $[ dependencies.AgentAssign.outputs['agentNameScript.AgentName'] ]
        pool:
          name: ai-on-edge-managed-pool
          vmImage: ubuntu-latest
          demands: Agent.Name -equals $(Agent.Name)
        steps:
          # Checkout repo
          - checkout: self

          # Pull MegaLinter docker image
          - script: docker pull oxsecurity/megalinter:v7
            displayName: Pull MegaLinter

          # Run MegaLinter
          # See here for required system props: https://github.com/oxsecurity/megalinter/blob/0f18f72065ffdeec09b616087b8298a3b13b2dee/megalinter/reporters/AzureCommentReporter.py#L7C1-L13C22
          - script: |
              docker run -v $(System.DefaultWorkingDirectory):/tmp/lint \
                --env-file <(env | grep -e SYSTEM_ -e BUILD_ -e TF_ -e AGENT_) \
                -e SYSTEM_ACCESSTOKEN=$(System.AccessToken) \
                -e GIT_AUTHORIZATION_BEARER=$(System.AccessToken) \
                -e SYSTEM_COLLECTIONURI='$(System.CollectionUri)' \
                -e SYSTEM_PULLREQUEST_PULLREQUESTID='$(System.PullRequest.PullRequestId)' \
                -e SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI='$(System.PullRequest.SourceRepositoryURI)' \
                -e SYSTEM_TEAMPROJECT='$(System.TeamProject)' \
                -e BUILD_BUILDID='$(Build.BuildId)' \
                -e BUILD_REPOSITORY_ID='$(Build.Repository.ID)' \
                -e AZURE_COMMENT_REPORTER='true' \
                oxsecurity/megalinter:v7
            displayName: Run MegaLinter

          # Upload MegaLinter reports
          - task: PublishPipelineArtifact@1
            condition: succeededOrFailed()
            displayName: Upload MegaLinter reports
            inputs:
              targetPath: "$(System.DefaultWorkingDirectory)/megalinter-reports/"
              artifactName: MegaLinterReport

      - job: MatrixBuildFolderCheck
        displayName: Check for changes in src directory
        dependsOn:
          - AgentAssign
          - MegaLinter
        variables:
          AgentName: $[ dependencies.AgentAssign.outputs['agentNameScript.AgentName'] ]
        pool:
          name: ai-on-edge-managed-pool
          vmImage: ubuntu-latest
          demands: Agent.Name -equals $(Agent.Name)
        steps:
          # Checkout repo
          - checkout: self
            fetchDepth: "0"

          # Check for changes in the src directory
          - bash: |
              echo "Checking for changes in the ./src/000_rp_enablement folder..."
              changed_files=$(git diff --name-only @~ @)
              if echo "$changed_files" | grep -q 'src/000_rp_enablement/.*\.sh$'; then
                echo "Changes detected in the ./src/000_rp_enablement folder shell files."
                echo "##vso[task.setvariable variable=changesInRpEnablementShell;isOutput=true]true"
              else
                echo "No changes detected in the ./src/000_rp_enablement folder shell files."
                echo "##vso[task.setvariable variable=changesInRpEnablementShell;isOutput=true]false"
              fi

              # check if PWSH files in rp_enablement have changed
              if echo "$changed_files" | grep -q 'src/000_rp_enablement/'; then
                echo "Changes detected in the ./src/000_rp_enablement folder pwsh files."
                echo "##vso[task.setvariable variable=changesInRpEnablementPwsh;isOutput=true]true"
              else
                echo "No changes detected in the ./src/000_rp_enablement folder pwsh files."
                echo "##vso[task.setvariable variable=changesInRpEnablementPwsh;isOutput=true]false"
              fi

              echo "Checking for changes in the first-level folders under src with .tf, .tfvars, .tfstate, or .hcl file changes..."
              changed_tf_folders=$(echo "$changed_files" |  # Get the list of changed files
                grep -E 'src/[^/]+/.*\.(tf|tfvars|tfstate|hcl)$' |  # Filter for .tf, .tfvars, .tfstate, or .hcl files in src directory
                awk -F'/' '{print $2}' |  # Extract the first-level folder names
                sort -u |  # Remove all duplicates
                sort -n |  # Sort the folder names numerically so they can be applied in order
                jq -R -s -c 'split("\n") |  # Convert the newline-separated list into a JSON array
                map(select(length > 0)) |  # Remove all empty entries
                map({key: ., value: {folderName: .}}) |  # Create JSON objects with folder name as keys, the keys are used to populate the AzDO job name
                from_entries')  # Convert entries to a JSON object

              if [ "$(echo $changed_tf_folders | jq 'length')" -ne 0 ]; then
                echo "Changes detected in the following Terraform folders: $changed_tf_folders"
                echo "##vso[task.setvariable variable=changesInInstall;isOutput=true]true"
                echo "##vso[task.setvariable variable=changedTFFolders;isOutput=true]$changed_tf_folders"
              else
                echo "No changes detected in the first-level folders under src with .tf, .tfvars, .tfstate, or .hcl file changes."
                echo "##vso[task.setvariable variable=changesInInstall;isOutput=true]false"
                echo "##vso[task.setvariable variable=changedTFFolders;isOutput=true]none"
              fi

            displayName: Check for changes in src folders
            name: matrixBuildFolderCheckTask

      - job: ResourceProviderShellScriptTest
        dependsOn:
          - AgentAssign
          - MatrixBuildFolderCheck
        variables:
          AgentName: $[ dependencies.AgentAssign.outputs['agentNameScript.AgentName'] ]
        pool:
          name: ai-on-edge-managed-pool
          vmImage: ubuntu-latest
          demands: Agent.Name -equals $(Agent.Name)
        # Check if the changeset includes 000_rp_enablement files and run if it does.
        condition: eq(dependencies.MatrixBuildFolderCheck.outputs['matrixBuildFolderCheckTask.changesInRpEnablementShell'], 'true')
        steps:
          - task: AzureCLI@2
            displayName: Azure CLI for Resource Provider Unregistration Script Test
            inputs:
              azureSubscription: "azdo-ai-for-edge-iac-for-edge"
              workingDirectory: "$(System.DefaultWorkingDirectory)/src/000_rp_enablement"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "uninstalling azure providers"
                ./unregister-azure-providers.sh aio-azure-resource-providers.txt
                echo "uninstalled azure providers"
          - task: AzureCLI@2
            displayName: Azure CLI for Resource Provider Registration Script Test
            inputs:
              azureSubscription: "azdo-ai-for-edge-iac-for-edge"
              workingDirectory: "$(System.DefaultWorkingDirectory)/src/000_rp_enablement"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "installing azure providers"
                ./register-azure-providers.sh aio-azure-resource-providers.txt
                echo "installed azure providers"

      - job: ResourceProviderPWSHScriptTest
        dependsOn:
          - MegaLinter
          - MatrixBuildFolderCheck
        pool:
          name: ai-on-edge-managed-pool
          vmImage: 'windows-2022'
        condition: eq(dependencies.MatrixBuildFolderCheck.outputs['matrixBuildFolderCheckTask.changesInRpEnablementPwsh'], 'true')
        variables:
          testResultsOutput: '$(System.DefaultWorkingDirectory)/PWSH-TEST-RESULTS.xml'
        steps:
          - powershell: ./.pipelines/subscripts/Invoke-Pester.ps1 -Path ./src/000_rp_enablement -OutputFile $(testResultsOutput)
            displayName: 'Run pester'
            workingDirectory: $(System.DefaultWorkingDirectory)

          - task: PublishTestResults@2
            displayName: Publish Test Results
            inputs:
              testRunTitle: 'Test Results for Pester'
              buildPlatform: 'Windows'
              testRunner: 'NUnit'
              testResultsFiles: '$(testResultsOutput)'
              failTaskOnFailedTests: true

      - job: TerraformClusterTest
        dependsOn:
          - AgentAssign
          - MegaLinter
          - MatrixBuildFolderCheck
        variables:
          AgentName: $[ dependencies.AgentAssign.outputs['agentNameScript.AgentName'] ]
        pool:
          name: ai-on-edge-managed-pool
          vmImage: ubuntu-latest
          demands: Agent.Name -equals $(Agent.Name)
        condition: eq(dependencies.MatrixBuildFolderCheck.outputs['matrixBuildFolderCheckTask.changesInInstall'], 'true')
        strategy:
          matrix:
            # Dynamically create a job for each folder in the changedTFFolders variable
            $[ dependencies.MatrixBuildFolderCheck.outputs['matrixBuildFolderCheckTask.changedTFFolders'] ]
          maxParallel: 1

        steps:
          # Initialize Terraform
          - task: TerraformInstaller@1
            displayName: "Install Terraform"
            inputs:
              terraformVersion: latest

          # Run terraform init
          - task: TerraformCLI@1
            displayName: "Terraform Init"
            inputs:
              command: init
              workingDirectory: $(System.DefaultWorkingDirectory)/src/$(folderName)/terraform/
              runAzLogin: true
              environmentServiceName: "azdo-ai-for-edge-iac-for-edge"
              backendType: azurerm
              # Service connection to authorize backend access. Supports Subscription & Management Group Scope
              backendServiceArm: "azdo-ai-for-edge-iac-for-edge"
              backendAzureRmResourceGroupName: "IaC_For_Edge"
              # azure location shortname of the backend resource group and storage account
              backendAzureRmResourceGroupLocation: "eastus"
              backendAzureRmStorageAccountName: "iacforedgetf"
              # azure blob container to store the state file
              backendAzureRmContainerName: "iacforedgetf"
              # azure blob file name
              backendAzureRmKey: infrax.tfstate

          # Check version and output issue if needed
          - task: AzureCLI@2
            displayName: "Terraform Provider version check"
            inputs:
              azureSubscription: "azdo-ai-for-edge-iac-for-edge"
              workingDirectory: $(System.DefaultWorkingDirectory)/src/$(folderName)/terraform/
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                version_data=$(terraform version -json)
                echo "$version_data" | jq .
                outdated=$(echo "$version_data" | jq -r '.terraform_outdated')
                provider_details=$(echo "$version_data" | jq -r '.provider_selections | to_entries[] | "\(.key) \(.key | split("/") | .[1]) \(.key | split("/") | .[2]) \(.value)"')

                while IFS= read -r line; do
                  registry=$(echo "$line" | awk '{print $1}')
                  source=$(echo "$line" | awk '{print $2}')
                  provider=$(echo "$line" | awk '{print $3}')
                  version=$(echo "$line" | awk '{print $4}')
                  url="https://registry.terraform.io/v1/providers/$source/$provider/versions"
                  response=$(curl -s "$url")

                  # Check versions
                  latest_version=$(echo "$response" | jq -r '.versions[].version' | sort -V | tail -n 1)
                  if [ "$(printf '%s\n' "$version" "$latest_version" | sort -V | tail -n 1)" != "$version" ]; then
                    echo "##vso[task.logissue type=warning]A newer version ($latest_version) is available for provider $provider from $source. Specified version: $version."
                  else
                    echo "Terraform provider: $provider version is up to date."
                  fi
                done <<< "$provider_details"

                if [ "$outdated" = "true" ]; then
                  echo "##vso[task.logissue type=warning]Terraform version is outdated."
                else
                  echo "Terraform version is up to date."
                fi

          - task: TerraformCLI@1
            displayName: "Terraform Validate"
            inputs:
              command: validate
              workingDirectory: $(System.DefaultWorkingDirectory)/src/$(folderName)/terraform/
            continueOnError: false

          # Parse variables.tf and construct the specific commandOptions required for the plan call
          - bash: |
              # get the tf variable file from the current matrix directory
              variables_file=$(System.DefaultWorkingDirectory)/src/$(folderName)/terraform/variables.tf
              # start the base command option for the coming TF Plan
              command_options="-out=$(Build.ArtifactStagingDirectory)/$(Build.Buildnumber).$(folderName).tfplan -detailed-exitcode"
              # if the variables file exists, parse it and for each variable,
              # see if we've set an AzDO pipeline variable to a matched name,
              # and then add that combination to that to the command options.
              # Special case is for Custom Locations OID because that is a
              # secrete value, and AzDO will not let you dynamically access
              # the variable name, you must know it, to map it.
              # e.g. https://stackoverflow.com/questions/75536144/azure-pipelines-error-tf401444-please-sign-in-at-least-once-as
              if [ -f "$variables_file" ]; then
                required_vars=$(grep -E 'variable "[^"]+" \{' $variables_file | awk -F'"' '{print $2}')
                for env_var in $(printenv | awk -F= '{print $1}'; echo "TF_VAR_CUSTOM_LOCATIONS_OID"); do
                  var_name=${env_var#TF_VAR_}
                  if echo "$required_vars" | grep -q "^${var_name,,}$"; then
                    command_options="$command_options -var ${var_name,,}=${!env_var}"
                  fi
                done
                echo $command_options
              fi
              echo "##vso[task.setvariable variable=commandOptions;isOutput=true]$command_options"
            displayName: "Parse variables.tf and build commandOptions"
            name: parseVariables

          # Run Terraform Plan for reporting
          - task: TerraformCLI@1
            displayName: "Terraform Plan"
            inputs:
              command: plan
              workingDirectory: $(System.DefaultWorkingDirectory)/src/$(folderName)/terraform/
              runAzLogin: true
              environmentServiceName: "azdo-ai-for-edge-iac-for-edge"
              publishPlanResults: "$(folderName) - Terraform Test Plan"
              commandOptions: $(parseVariables.commandOptions)

          # Terraform Test Command
          # This is not yet implemented, tracking here: https://github.com/jason-johnson/azure-pipelines-tasks-terraform/issues/398
          # Once this command is available, the AZ CLI below can be removed
          # - task: TerraformCLI@2
          #   displayName: 'terraform test'
          #   inputs:
          #     command: test
          #     workingDirectory: $(System.DefaultWorkingDirectory)/src/$(folderName)/terraform/tests"
          #     commandOptions: "-filter=cluster.tftest.hcl"

          # NOTE: For this task to work it needs the subscription id set for the AzureAD provider
          # beyond the integrated MSI.

          - task: AzureCLI@2
            name: TerraformTest
            displayName: Azure CLI for Terraform CLI test run
            inputs:
              azureSubscription: "azdo-ai-for-edge-iac-for-edge"
              workingDirectory: $(System.DefaultWorkingDirectory)/src/$(folderName)/terraform/
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                # Export the ARM subscription ID so Terraform tests can be executed
                export ARM_SUBSCRIPTION_ID=$(SUBSCRIPTION_ID)
                # Define the log file from the test output to read up
                log_file="$(System.DefaultWorkingDirectory)/$(folderName)_test_output.log"
                echo "Writing Terraform test output to $log_file"
                # run TF tests
                terraform test -json -var custom_locations_oid=$(TF_VAR_CUSTOM_LOCATIONS_OID) > $log_file
                unset ARM_SUBSCRIPTION_ID

                # Read each line of the log file and extract the @timestamp and @message fields
                while IFS= read -r line; do
                  echo "$line" | jq -r '"\(.["@timestamp"]) .... \(.["@message"])"'
                done < "$log_file"

                # Get the last line of the output and parse it for the word "Success"
                last_line=$(tail -n 1 "$log_file")
                if echo "$last_line" | jq -e '.["@message"]' | grep -q "Success"; then
                  echo "Terraform tests passed."
                else
                  echo "Terraform tests failed."
                  exit 1
                fi

          - task: UseNode@1
            inputs:
              version: '22.x'
            condition: always()

          # https://github.com/Liam-Johnston/tftest-to-junitxml
          - script: |
              npm install -g tftest-to-junitxml
            displayName: 'Install tftest-to-junitxml'
            condition: always()

          - script: |
              npx tftest-to-junitxml "$(System.DefaultWorkingDirectory)/$(folderName)_test_output.log"
            displayName: 'Convert Terraform test output to JUnit XML'
            condition: always()

          - task: PublishTestResults@2
            displayName: Publish Test Results
            inputs:
              testResultsFiles: 'TEST-terraform.xml'
              testRunTitle: 'Test Results for $(folderName)'
              buildPlatform: 'Linux'
              testRunner: 'JUnit'
              failTaskOnFailedTests: true
            condition: always()
