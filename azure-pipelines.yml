# Starter pipeline
# Start with a minimal pipeline that you can customize to build and deploy your code.
# Add steps that build, run tests, deploy, and more:
# https://aka.ms/yaml

---
trigger:
  branches:
    include:
      - main

variables:
  isMain: $[eq(variables['Build.SourceBranch'], 'refs/heads/main')]

pool:
  vmImage: ubuntu-latest

stages:
  - stage: Main
    displayName: Main Build
    # dependsOn: string | [ string ]
    condition: eq(variables.isMain, true)
    # pool: string | pool
    # variables: { string: string } | [ variable | variableReference ]
    jobs:
      - job: DependencyScan
        pool:
          vmImage: ubuntu-latest
        steps:
          # Checkout repo
          - checkout: self

          # Initialize dependency scan and fail the build if it does not pass
          - task: ms.vss-governance-buildtask.governance-build-task-component-detection.ComponentGovernanceComponentDetection@0
            displayName: 'Component Detection'
            inputs:
              failOnAlert: true

      # Run MegaLinter to detect linting and security issues
      - job: MegaLinter
        pool:
          vmImage: ubuntu-latest
        steps:
          # Checkout repo
          - checkout: self

          # Pull MegaLinter docker image
          - script: docker pull oxsecurity/megalinter:v7
            displayName: Pull MegaLinter

          # Run MegaLinter - for the main branch the reporter needs to be disabled
          - script: |
              docker run -v $(System.DefaultWorkingDirectory):/tmp/lint \
                --env-file <(env | grep -e SYSTEM_ -e BUILD_ -e TF_ -e AGENT_) \
                -e SYSTEM_ACCESSTOKEN=$(System.AccessToken) \
                -e GIT_AUTHORIZATION_BEARER=$(System.AccessToken) \
                -e AZURE_COMMENT_REPORTER='false' \
                oxsecurity/megalinter:v7
            displayName: Run MegaLinter

  - stage: PR
    displayName: PR Build Process
    # dependsOn: string | [ string ]
    condition: eq(variables.isMain, false)
    # pool: string | pool
    # variables: { string: string } | [ variable | variableReference ]
    jobs:
      - job: DependencyScan
        pool:
          vmImage: ubuntu-latest
        steps:
          # Checkout repo
          - checkout: self

          # Initialize dependency scan and fail the build if it does not pass
          - task: ms.vss-governance-buildtask.governance-build-task-component-detection.ComponentGovernanceComponentDetection@0
            displayName: 'Component Detection'
            inputs:
              failOnAlert: true

      # Run MegaLinter to detect linting and security issues
      - job: MegaLinter
        pool:
          vmImage: ubuntu-latest
        dependsOn: DependencyScan
        steps:
          # Checkout repo
          - checkout: self

          # Pull MegaLinter docker image
          - script: docker pull oxsecurity/megalinter:v7
            displayName: Pull MegaLinter

          # Run MegaLinter
          # See here for required system props: https://github.com/oxsecurity/megalinter/blob/0f18f72065ffdeec09b616087b8298a3b13b2dee/megalinter/reporters/AzureCommentReporter.py#L7C1-L13C22
          - script: |
              docker run -v $(System.DefaultWorkingDirectory):/tmp/lint \
                --env-file <(env | grep -e SYSTEM_ -e BUILD_ -e TF_ -e AGENT_) \
                -e SYSTEM_ACCESSTOKEN=$(System.AccessToken) \
                -e GIT_AUTHORIZATION_BEARER=$(System.AccessToken) \
                -e SYSTEM_COLLECTIONURI='$(System.CollectionUri)' \
                -e SYSTEM_PULLREQUEST_PULLREQUESTID='$(System.PullRequest.PullRequestId)' \
                -e SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI='$(System.PullRequest.SourceRepositoryURI)' \
                -e SYSTEM_TEAMPROJECT='$(System.TeamProject)' \
                -e BUILD_BUILDID='$(Build.BuildId)' \
                -e BUILD_REPOSITORY_ID='$(Build.Repository.ID)' \
                -e AZURE_COMMENT_REPORTER='true' \
                oxsecurity/megalinter:v7
            displayName: Run MegaLinter

          # Upload MegaLinter reports
          - task: PublishPipelineArtifact@1
            condition: succeededOrFailed()
            displayName: Upload MegaLinter reports
            inputs:
              targetPath: "$(System.DefaultWorkingDirectory)/megalinter-reports/"
              artifactName: MegaLinterReport

      - job: CheckRpEnablementChanges
        displayName: Check for changes in rp_enablement folder
        pool:
          vmImage: ubuntu-latest
        dependsOn: MegaLinter
        steps:
          # Checkout repo
          - checkout: self
            fetchDepth: 0

          # Check for changes in the rp_enablement folder
          - bash: |
              echo "Checking for changes in the ./src/rp_enablement folder..."
              if git diff --name-only @~ @ | grep -q 'src/rp_enablement/'; then
                echo "Changes detected in the ./src/rp_enablement folder."
                echo "##vso[task.setvariable variable=changesInRpEnablement;isOutput=true]true"
              else
                echo "No changes detected in the ./src/rp_enablement folder."
                echo "##vso[task.setvariable variable=changesInRpEnablement;isOutput=true]false"
              fi
            displayName: Check for rp_enablement changes
            name: changesInRpEnablementScript

      - job: ResourceProviderScriptTest
        pool:
          vmImage: ubuntu-latest
        dependsOn: CheckRpEnablementChanges
        # Check if the changeset includes rp_enablement files and run if it does.
        condition: eq(dependencies.CheckRpEnablementChanges.outputs['changesInRpEnablementScript.changesInRpEnablement'], 'true')
        steps:
          - task: AzureCLI@2
            displayName: Azure CLI for Resource Provider Unregistration Script Test
            inputs:
              azureSubscription: 'azdo-ai-for-edge-iac-for-edge'
              workingDirectory: "$(System.DefaultWorkingDirectory)/src/rp_enablement"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "uninstalling azure providers"
                ./unregister-azure-providers.sh aio-azure-resource-providers.txt
                echo "uninstalled azure providers"
          - task: AzureCLI@2
            displayName: Azure CLI for Resource Provider Registration Script Test
            inputs:
              azureSubscription: 'azdo-ai-for-edge-iac-for-edge'
              workingDirectory: "$(System.DefaultWorkingDirectory)/src/rp_enablement"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "installing azure providers"
                ./register-azure-providers.sh aio-azure-resource-providers.txt
                echo "installed azure providers"

      - job: CheckTerraformClusterInstallChanges
        displayName: Check for changes in cluster install terraform folder
        pool:
          vmImage: ubuntu-latest
        dependsOn: MegaLinter
        steps:
          # Checkout repo
          - checkout: self
            fetchDepth: 0

          # Check for changes in the cluster_install folder
          - bash: |
              echo "Checking for changes in the ./src/cluster_install folder..."
              if git diff --name-only @~ @ | grep -qE 'src/cluster_install/.*\.(tf|tfvars|tfstate|hcl)$'; then
                echo "Changes detected in the ./src/cluster_install folder."
                echo "##vso[task.setvariable variable=changesInClusterInstall;isOutput=true]true"
              else
                echo "No changes detected in the ./src/cluster_install folder."
                echo "##vso[task.setvariable variable=changesInClusterInstall;isOutput=true]false"
              fi
            displayName: Check for cluster_install changes
            name: changesInClusterInstallScript

      - job: TerraformTest
        pool:
          vmImage: ubuntu-latest
        dependsOn: CheckTerraformClusterInstallChanges
        condition: eq(dependencies.CheckTerraformClusterInstallChanges.outputs['changesInClusterInstallScript.changesInClusterInstall'], 'true')
        steps:
          # Initialize Terraform
          - task: TerraformInstaller@1
            displayName: install terraform
            inputs:
              terraformVersion: latest

          # Check version and output issue if needed
          - task: TerraformCLI@1
            displayName: 'Check terraform version'
            inputs:
              command: version

          # Run terraform init
          - task: TerraformCLI@1
            displayName: 'Terraform Init'
            inputs:
              command: init
              workingDirectory: "$(System.DefaultWorkingDirectory)/src/cluster_install/terraform/"
              runAzLogin: true
              environmentServiceName: 'azdo-ai-for-edge-iac-for-edge'
              backendType: azurerm
              # Service connection to authorize backend access. Supports Subscription & Management Group Scope
              backendServiceArm: 'azdo-ai-for-edge-iac-for-edge'
              backendAzureRmResourceGroupName: 'IaC_For_Edge'
              # azure location shortname of the backend resource group and storage account
              backendAzureRmResourceGroupLocation: 'eastus'
              backendAzureRmStorageAccountName: 'iacforedgetf'
              # azure blob container to store the state file
              backendAzureRmContainerName: 'iacforedgetf'
              # azure blob file name
              backendAzureRmKey: infrax.tfstate

          - task: TerraformCLI@1
            displayName: 'Terraform Validate'
            inputs:
              command: validate
              workingDirectory: "$(System.DefaultWorkingDirectory)/src/cluster_install/terraform/"

          # Run Terraform Plan for reporting
          - task: TerraformCLI@1
            displayName: 'Terraform Plan'
            inputs:
              command: plan
              workingDirectory: "$(System.DefaultWorkingDirectory)/src/cluster_install/terraform/"
              runAzLogin: true
              environmentServiceName: 'azdo-ai-for-edge-iac-for-edge'
              publishPlanResults: 'Terrafrom Test Plan'
              commandOptions: '-out=$(Build.ArtifactStagingDirectory)/$(Build.Buildnumber).tfplan
                -detailed-exitcode
                -var environment=$(TF_VAR_ENVIRONMENT)
                -var resource_prefix=$(TF_VAR_RESOURCE_PREFIX)
                -var location=$(TF_VAR_LOCATION)
                -var existing_resource_group_name=$(TF_VAR_EXISTING_RESOURCE_GROUP_NAME)
                -var vm_sku_size=$(TF_VAR_VM_SKU_SIZE)
                -var custom_locations_oid=$(TF_VAR_CUSTOM_LOCATIONS_OID)'

          # Terraform Test Command
          # This is not yet implemented, tracking here: https://github.com/jason-johnson/azure-pipelines-tasks-terraform/issues/398
          # Once this command is available, the AZ CLI below can be removed
          # - task: TerraformCLI@2
          #   displayName: 'terraform test'
          #   inputs:
          #     command: test
          #     workingDirectory: "$(System.DefaultWorkingDirectory)/src/cluster_install/terraform/tests"
          #     commandOptions: "-filter=cluster.tftest.hcl"

          # NOTE: For this task to work it needs the subscription id set for the AzureAD provider
          # beyond the integrated MSI.
          - task: AzureCLI@2
            displayName: Azure CLI for Terraform CLI test run
            inputs:
              azureSubscription: 'azdo-ai-for-edge-iac-for-edge'
              workingDirectory: "$(System.DefaultWorkingDirectory)/src/cluster_install/terraform"
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                # Export the ARM subscription ID so Terraform tests can be executed
                export ARM_SUBSCRIPTION_ID=$(SUBSCRIPTION_ID)
                terraform test -json -var custom_locations_oid=$(TF_VAR_CUSTOM_LOCATIONS_OID) > test_output.log
                unset ARM_SUBSCRIPTION_ID

                # Define the log file from the test output to read up
                log_file="test_output.log"

                # Read each line of the log file and extract the @timestamp and @message fields
                while IFS= read -r line; do
                  echo "$line" | jq -r '"\(.["@timestamp"]) .... \(.["@message"])"'
                done < "$log_file"

                # Get the last line of the output and parse it for the word "Success"
                last_line=$(tail -n 1 test_output.log)
                if echo "$last_line" | jq -e '.["@message"]' | grep -q "Success"; then
                  echo "Terraform tests passed."
                else
                  echo "Terraform tests failed."
                  exit 1
                fi
